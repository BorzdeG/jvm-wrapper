#!/usr/bin/env python2
# -*- coding: utf-8 -*-
import commands
import hashlib
import logging
import platform
import re
import shlex
# noinspection PyProtectedMember
import sys
from glob import glob
from os import environ, path, linesep, getcwd
from shutil import move, rmtree
# noinspection PyProtectedMember
from subprocess import CalledProcessError, PIPE, Popen, check_call, list2cmdline
from tempfile import mkdtemp
from urllib2 import urlopen

from pip._vendor import requests
# noinspection PyProtectedMember
from pip._vendor.requests.models import ITER_CHUNK_SIZE

# https://docs.python.org/2/library/logging.html
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s [%(levelname)-8s] [line:%(lineno)-3d] %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S',
                    filename='jdkw.log',
                    filemode='w',
                    )

_default_properties = {
    'JDK_FAMILY': '8'
}


class OS:
    __instance = None

    @staticmethod
    def instance():
        if OS.__instance is None:
            OS.__instance = OS()
        return OS.__instance

    system = 'darwin' if platform.system() == 'Darwin' else 'linux'
    arch = 'x64' if platform.architecture()[0] == '64bit' else 'i586'

    CMD_HDIUTIL = 'hdiutil'
    CMD_XAR = 'xar'
    CMD_CPIO = 'cpio'

    _CMD_FOR_DARWIN = [CMD_HDIUTIL, CMD_XAR, CMD_CPIO]

    @staticmethod
    def is_darwin():
        return OS.instance().system == 'darwin'

    def check_require_commands(self):
        if self.is_darwin():
            return self.cmd_exists(self._CMD_FOR_DARWIN)

    @staticmethod
    def cmd_exists(cmds):
        for cmd in cmds:
            logging.debug('check exists command: ' + cmd)
            result = commands.getstatusoutput(' '.join([
                'command',
                '-v',
                cmd,
            ]))
            if result[0]:
                logging.error('command not found: ' + cmd)
                return False
        return True

    @staticmethod
    def run_command(arguments, cwd=None, show_error=True):
        logging.debug('working dir: ' + (str(cwd) or ''))
        logging.debug('command line: ' + list2cmdline(arguments))
        try:
            return check_call(args=arguments, cwd=cwd)
        except CalledProcessError, e:
            if show_error:
                logging.error('call error. code: ' + str(e.returncode))
                logging.error(e.output)

    @staticmethod
    def run_large_command(arguments, environment=environ):
        cwd_ = getcwd()
        logging.debug('cwd=' + cwd_)
        process = Popen(args=arguments, stdout=PIPE, stderr=PIPE, env=environment, cwd=cwd_)
        while True:
            output = process.stdout.readline()
            error = process.stderr.readline()
            if output == '' and error == '' and process.poll() is not None:
                break
            if output:
                sys.stdout.write(output.strip())
                sys.stdout.write(linesep)
            if error:
                sys.stderr.write(error.strip())
                sys.stderr.write(linesep)
        return process.poll()

    def __init__(self):
        pass

    def __str__(self):
        return 'OsParams{' \
               + 'system: \'' + self.system + '\'' \
               + ', arch: \'' + self.arch + '\'' \
               + '}'


class JDKDownloader:
    __instance = None
    __params = {
        'ARCHIVE_EXTENSION': 'dmg' if OS.is_darwin() else 'tar.gz',
        'ARCHIVE_URL':       None,
        'ARCHIVE_SHA256':    None,
        'ARCHIVE_FILE':      None,
    }

    @staticmethod
    def instance():
        if JDKDownloader.__instance is None:
            JDKDownloader.__instance = JDKDownloader()
        return JDKDownloader.__instance

    def __init__(self):
        pass

    def __str__(self):
        return 'JDKDownloader{' \
               + 'archive.extension: \'' + self.__params['ARCHIVE_EXTENSION'] + '\'' \
               + ', archive.url: \'' + (str(self.__params['ARCHIVE_URL']) or '') + '\'' \
               + ', archive.sha256: \'' + (str(self.__params['ARCHIVE_SHA256']) or '') + '\'' \
               + ', archive.file: \'' + (str(self.__params['ARCHIVE_FILE']) or '') + '\'' \
               + '}'

    @staticmethod
    def archive_file():
        return JDKDownloader.instance().__params['ARCHIVE_FILE']

    def get_archive_url(self):
        archive_url_ = self.__params['ARCHIVE_URL']
        if archive_url_:
            return archive_url_

        try:
            latest_page = self.__get_latest_page()
            if latest_page:
                page_jdk = urlopen('http://www.oracle.com' + latest_page).read()
                mask = 'http://.*?\.' + self.__params['ARCHIVE_EXTENSION']
                archive_url_ = re.search('(' + mask + ')', page_jdk).group(1)
                self.__params['ARCHIVE_SHA256'] = re.search(mask + '.*?"SHA256":"(.*?)"', page_jdk).group(1)
        finally:
            self.__params['ARCHIVE_URL'] = archive_url_
        return archive_url_

    @staticmethod
    def __calculate_sha256(filepath, block_size=65536):
        result = ''
        try:
            if path.isfile(filepath):
                sha256 = hashlib.sha256()
                with open(filepath, 'rb') as f:
                    for block in iter(lambda: f.read(block_size), b''):
                        sha256.update(block)
                result = sha256.hexdigest()
        finally:
            logging.debug('sha256 for file \'' + filepath + '\' = ' + result)
        return result

    @staticmethod
    def download():
        # noinspection PyUnusedLocal
        if not JDKDownloader.__params['ARCHIVE_URL']:
            JDKDownloader.instance().get_archive_url()

        archive_url_ = str(JDKDownloader.__params['ARCHIVE_URL'])
        archive_file_ = path.join(JdkWrapper.home,
                                  JdkWrapper.jdk_full_name() + '.' + JDKDownloader.__params['ARCHIVE_EXTENSION']
                                  )
        try:
            archive_sha256_ = JDKDownloader.__calculate_sha256(archive_file_)
            if path.isfile(archive_file_) and archive_sha256_ == JDKDownloader.__params['ARCHIVE_SHA256']:
                # noinspection PyUnusedLocal
                return True

            logging.debug('download file: ' + archive_url_)
            req = requests.get(archive_url_, stream=True, cookies={'oraclelicense': 'accept-securebackup-cookie'})
            with open(archive_file_, 'wb') as fp:
                for chunk in req.iter_content(chunk_size=ITER_CHUNK_SIZE):
                    if chunk:
                        fp.write(chunk)
                        fp.flush()

            return True
        finally:
            JDKDownloader.__params['ARCHIVE_FILE'] = archive_file_

    @staticmethod
    def __get_latest_page():
        page_index = urlopen('http://www.oracle.com/technetwork/java/javase/downloads/index.html').read()
        try:
            return re.search('name="JDK' + JdkWrapper.jvm_family() + '".*?"(/technetwork.*?)"', page_index).group(1)
        except AttributeError:
            return ''


class JdkUnpacker:
    def __init__(self):
        pass

    def unpack(self):
        if OS.is_darwin():
            self.__darwin_unpack()

    def __darwin_unpack(self):
        try:
            self.__darwin_detach(show_error=False)
            self.__darwin_attach()
            self.__darwin_pkg_unpack()
        finally:
            self.__darwin_detach()

    @staticmethod
    def __darwin_mount_path():
        mount_path_ = path.join('/Volumes', JdkWrapper.jdk_full_name())
        logging.debug('mount.path: ' + mount_path_)
        return mount_path_

    @staticmethod
    def __darwin_detach(show_error=True):
        OS.run_command(arguments=[OS.CMD_HDIUTIL,
                                  'detach',
                                  JdkUnpacker.__darwin_mount_path(),
                                  '-quiet',
                                  '-force',
                                  ],
                       show_error=show_error)

    @staticmethod
    def __darwin_attach():
        OS.run_command(arguments=[OS.CMD_HDIUTIL,
                                  'attach',
                                  JDKDownloader.archive_file(),
                                  '-quiet',
                                  '-mountpoint',
                                  JdkUnpacker.__darwin_mount_path(),
                                  ])

    def __darwin_pkg_unpack(self):
        tmp_dir = mkdtemp()
        logging.debug('tmp.dir: ' + tmp_dir)
        try:
            OS.run_command(arguments=[OS.CMD_XAR, '-xf', glob(path.join(self.__darwin_mount_path(), '*.pkg'))[0], '.', ], cwd=tmp_dir)

            OS.run_command(arguments=[OS.CMD_CPIO, '--quiet', '-diI', path.join(glob(path.join(tmp_dir, 'jdk*'))[0], 'Payload')],
                           cwd=tmp_dir)

            prev_dir = path.join(tmp_dir, 'Contents')
            new_dir = path.dirname(JdkWrapper.jdk_home())
            logging.debug('moving \'' + prev_dir + '\' to \'' + new_dir + '\'')
            move(prev_dir, new_dir)
        finally:
            rmtree(tmp_dir)


class JdkWrapper:
    __instance = None

    @staticmethod
    def instance():
        if JdkWrapper.__instance is None:
            JdkWrapper.__instance = JdkWrapper()
        return JdkWrapper.__instance

    home = path.join(path.expanduser('~'), '.jvm')
    _property_file = 'jvmw.properties'
    _params = {
        'JDK_FAMILY':         _default_properties['JDK_FAMILY'],
        'JDK_FULL_NAME':      None,
        'JDK_HOME':           None,
        'JAVA_HOME':          None,
        'JVM_HOME_ROOT_NAME': None,
    }

    def __init__(self):
        self.__properties_load_from_file(self.home)
        self.__properties_load_from_file('.')
        self.__properties_load_from_environ()
        self.__properties_calculate()

    @staticmethod
    def jvm_family():
        return JdkWrapper.instance()._params['JDK_FAMILY']

    @staticmethod
    def jdk_full_name():
        return JdkWrapper.instance()._params['JDK_FULL_NAME']

    @staticmethod
    def jdk_home():
        return JdkWrapper.instance()._params['JDK_HOME']

    def __properties_load_from_environ(self):
        for key in self._params:
            if key in environ:
                self._params[key] = environ.get(key)

    def __properties_load_from_file(self, root_dir):
        file_path = path.join(root_dir, self._property_file)
        logging.debug('file_path: ' + file_path)
        if not path.isfile(file_path):
            logging.info('not found: ' + file_path)
            return
        split_properties = [line.split("=") for line in open(file_path)]
        for key, value in split_properties:
            logging.debug(key + ' = ' + value)
            if len(value) > 0:
                self._params[key] = value

    def __properties_calculate(self):
        self._params['JDK_FULL_NAME'] = 'jdk' + self._params['JDK_FAMILY']
        self._params['JDK_HOME'] = path.join(self.home,
                                             self._params['JDK_FULL_NAME'],
                                             ('Home' if OS.is_darwin() else '')
                                             )
        self._params['JAVA_HOME'] = self._params['JDK_HOME']
        self._params['JVM_EXEC'] = path.join(self._params['JDK_HOME'], 'bin', 'java')

    def __has_update(self):
        if not path.isfile(self._params['JVM_EXEC']):
            return True
        return False

    def update(self):
        if self.__has_update():
            self.__update()

    @staticmethod
    def __update():
        if not JDKDownloader.download():
            logging.error('can\'t file: ' + JDKDownloader.instance().get_archive_url())
            return
        JdkUnpacker().unpack()

    def run(self):
        args = sys.argv
        if len(args) < 2:
            exit()
        args.remove(args[0])
        args[0] = path.join(self._params['JDK_HOME'], 'bin', args[0])
        logging.info('command: ' + str(args))
        exit(OS.run_large_command(arguments=args, environment=self.__prepare_environment()))

    def __prepare_environment(self):
        environment = environ.copy()
        for key in ['JDK_HOME', 'JAVA_HOME']:
            environment[key] = self._params[key]
        return environment

    def __str__(self):
        return 'JdkWrapper{' \
               + 'home: \'' + self.home + '\'' \
               + ', params: ' + str(self._params) \
               + '}'


if not OS.instance().check_require_commands():
    exit(1)
jdk_wrapper = JdkWrapper.instance()
jdk_wrapper.update()

logging.info(str(OS.instance()))
logging.info(str(JdkWrapper.instance()))
logging.info(str(JDKDownloader.instance()))

jdk_wrapper.run()
