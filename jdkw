#!/usr/bin/env bash

#
JVMW_HOME=${HOME}/.jvm/
JVMW_PROPERTY_FILE="${JVMW_PROPERTY_FILE:-./jvmw.properties}"
OS=$(uname | tr '[:upper:]' '[:lower:]')
ARCH=$([[ "$(uname -m)" == "x86_64" ]] && echo "x64" || echo "i586")
ARCHIVE_EXT=$([[ "$(uname)" == "Darwin" ]] && echo "dmg" || echo "tar.gz")
#
REQUIRED_COMMANDS_CORE='awk tr grep head rm mv cd curl'
REQUIRED_COMMANDS_DARWIN='hdiutil xar cpio shasum'
REQUIRED_COMMANDS_LINUX='sha256sum tar'
#
JDK_FAMILY=${JDK_FAMILY}
JDK_UPDATE_VERSION=${JDK_UPDATE_VERSION}
#

mkdir -p "${JVMW_HOME}"

function debug() {
	>&2 echo "[DEBUG] $*"
	printf ''
}

function print_debug_info() {
	for key in OS ARCH ARCHIVE_EXT JDK_FAMILY JDK_UPDATE_VERSION JDK_FULL_VERSION JDK_CHECK_VERSION JDK_FULL_NAME JDK_HOME JAVA_HOME JAVA_EXEC JDK_PAGE_URL ARCHIVE_JDK_URL ARCHIVE_JDK_SHA256 ARCHIVE_FILE; do
		>&2 echo "[DEBUG] ${key}=${!key}";
	done
}

function error() {
	>&2 echo "[ERROR] $*"
	print_debug_info
	exit 1
}


function check_program_exists() {
	# shellcheck disable=SC2068
	for cmd in $@; do
		if [[ "$("$cmd" --version 2>&1)" == *"command not found"* ]]; then
			error "command not found: ${cmd}"
		fi
	done
}

function properties_parser() {
	while IFS='=' read -r key value || [[ -n "$key" ]]; do
		[[ -z "${!key}" ]] && eval "${key}='${value}'"
	done <<<"$1"
}

function properties_default() {
	cat << EOF
JDK_FAMILY=9
JDK_UPDATE_VERSION=
EOF
}

function properties_calculate() {
	if [[ ${JDK_FAMILY} -lt 9 ]]; then
		JDK_FULL_VERSION="${JDK_FAMILY}$(if [[ ! -z "${JDK_UPDATE_VERSION}" ]]; then
			echo "u${JDK_UPDATE_VERSION}";
		fi)"
		JDK_CHECK_VERSION="1.${JDK_FAMILY}.0$(if [[ ! -z "${JDK_UPDATE_VERSION}" ]]; then
			echo "_${JDK_UPDATE_VERSION}";
		fi)"
	else
		#	TODO Fix mask for version greater than or equal to 9
		JDK_FULL_VERSION="${JDK_FAMILY}"
		JDK_CHECK_VERSION="${JDK_FAMILY}.0.1"
	fi
	JDK_FULL_NAME="jdk${JDK_FULL_VERSION}"
	JDK_HOME=$(echo "${JVMW_HOME}/${JDK_FULL_NAME}/$(if [[ "${OS}" == 'darwin' ]]; then
		echo 'Home';
	fi)" | sed s#//*#/#g)
	JAVA_HOME="${JDK_HOME}"
	JAVA_EXEC=$(echo "${JAVA_HOME}/bin/java" | sed s#//*#/#g)
	ARCHIVE_FILE=$(echo "${JVMW_HOME}/${JDK_FULL_NAME}.${ARCHIVE_EXT}" | sed s#//*#/#g)
}

function get_latest_jdk_page_url() {
	JDK_PAGE_URL=http://www.oracle.com$(curl -s http://www.oracle.com/technetwork/java/javase/downloads/index.html | tr '"' $'\n' | grep "jdk${JDK_FAMILY}-downloads" | head -1)
}

function get_archive_jdk_url() {
	get_latest_jdk_page_url
	local -r content=$(curl -s "${JDK_PAGE_URL}")
	local -r awk_mask='^downloads.*?/jdk/'${JDK_FULL_VERSION}'.*?-'${ARCH}'.*?.'${ARCHIVE_EXT}
	debug "awk_mask=${awk_mask}"

	local -r awk_sep='":"|", "|"}'
	# shellcheck disable=SC2086
	local -r row=$(echo "${content}" | awk '{ if (match($0, "'${awk_mask}'")) print }' | head -1)
	ARCHIVE_JDK_URL=$(echo "${row}" | awk -F"${awk_sep}" '{ print $5 }')
	ARCHIVE_JDK_SHA256=$(echo "${row}" | awk -F"${awk_sep}" '{ print $9 }')
	debug "ARCHIVE_JDK_URL=${ARCHIVE_JDK_URL}"
}

function download_archive_jdk() {
	if [[ -z "${ARCHIVE_JDK_URL}" ]]; then
		error "empty ARCHIVE_JDK_URL"
	fi
	if [[ -f "${ARCHIVE_FILE}" ]]; then
		if [[ "${OS}" == "darwin" ]]; then
			sha256=$(shasum -a 256 "${ARCHIVE_FILE}" | cut -d' ' -f 1)
		else
			sha256=$(sha256sum "${ARCHIVE_FILE}" | cut -d' ' -f 1)
		fi
		if [[ "${sha256}" == "${ARCHIVE_JDK_SHA256}" ]]; then
			return;
		fi
	fi
	curl -o "${ARCHIVE_FILE}" -L -H "Cookie: oraclelicense=accept-securebackup-cookie" "${ARCHIVE_JDK_URL}"
}

function unpack_dmg() {
	hdiutil detach "/Volumes/${JDK_FULL_NAME}" -quiet -force 2> /dev/null
	hdiutil attach "${ARCHIVE_FILE}" -quiet -mountpoint "/Volumes/${JDK_FULL_NAME}" || exit 1
	local -r PKG_FILE_NAME=$(find "/Volumes/${JDK_FULL_NAME}" -mindepth 1 -maxdepth 1 -name '*.pkg')
	mkdir -p "${JVMW_HOME}/${JDK_FULL_NAME}.tmp" || exit 1
	cd "${JVMW_HOME}/${JDK_FULL_NAME}.tmp/" || { echo "can't change directory: ${JVMW_HOME}/${JDK_FULL_NAME}.tmp/";
		exit 1; }
	xar -xf "${PKG_FILE_NAME}" . &> /dev/null || exit 1
	for dir in ./*jdk*; do
		cpio -i <"${dir}/Payload" || exit 1
	done
	rm -Rf "${JVMW_HOME:?}/${JDK_FULL_NAME}/"
	mv Contents "../${JDK_FULL_NAME}" 1> /dev/null 2>&1 || exit 1
	cd - || exit 1
	# FIXME
	rm -Rf "${JVMW_HOME:?}/${JDK_FULL_NAME}.tmp/"
	#		rm -Rf "${JVMW_HOME:?}/${JDK_FULL_NAME}.tmp/" "${ARCHIVE_FILE}"
	#
	hdiutil detach "/Volumes/${JDK_FULL_NAME}" -quiet -force
}

function unpack_linux() {
	mkdir -p "${JVMW_HOME}/${JDK_FULL_NAME}.tmp" || exit 1
	tar xf "${ARCHIVE_FILE}" -C "${JVMW_HOME}/${JDK_FULL_NAME}.tmp" || exit 1
	mv "$(find "${JVMW_HOME}/${JDK_FULL_NAME}.tmp" -mindepth 1 -maxdepth 1 -type d)" "${JVMW_HOME}/${JDK_FULL_NAME}" || exit 1
	# FIXME
	rm -Rf "${JVMW_HOME:?}/${JDK_FULL_NAME}.tmp/"
	#		rm -Rf "${JVMW_HOME:?}/${JDK_FULL_NAME}.tmp/" "${ARCHIVE_FILE}"
}

function update_jdk() {
	get_archive_jdk_url
	download_archive_jdk
	if [[ "${ARCHIVE_EXT}" == "dmg" ]]; then
		unpack_dmg
	else
		unpack_linux
	fi
}

# build properties
[[ -f "${JVMW_HOME}/${JVMW_PROPERTY_FILE}" ]] && { properties_parser "$(cat "${JVMW_HOME}/${JVMW_PROPERTY_FILE}")"; }
[[ -f "${JVMW_PROPERTY_FILE}" ]] && { properties_parser "$(cat "${JVMW_PROPERTY_FILE}")"; }
properties_parser "$(properties_default)"
properties_calculate


# main section
if [[ "${OS}" == "darwin" ]]; then
	check_program_exists "${REQUIRED_COMMANDS_CORE}" "${REQUIRED_COMMANDS_DARWIN}"
else
	check_program_exists "${REQUIRED_COMMANDS_CORE}" "${REQUIRED_COMMANDS_LINUX}"
fi
#
if [[ ! -f "${JAVA_EXEC}" ]]; then
	update_jdk
elif [[ "$(${JAVA_EXEC} -version 2>&1 | head -1)" != *"${JDK_CHECK_VERSION}"* ]]; then
	error 'The local Java version does not match the expected version'
fi
#
if [[ "$1" == "info" ]]; then
	echo "JDK_HOME=${JDK_HOME}"
	echo "JAVA_HOME=${JAVA_HOME}"
elif [[ -z "${JDK_HOME}" ]]; then
	error "can't JDK_HOME"
elif [[ -z "$1" ]]; then
	error "command is empty"
else # execute program
	print_debug_info
	debug "command: ${JDK_HOME}/bin/$1" "${@:2}"
	eval "${JDK_HOME}/bin/$1" "${@:2}"
fi